# Бутылка Клейна: Математическое Описание

## Введение

Бутылка Клейна — это пример неориентируемой поверхности в топологии. В отличие от обычных поверхностей, таких как сфера или тор, у неё нет чётко определённых "внутренней" и "внешней" сторон. 
Попытка последовательно определить "право" и "лево" при движении по поверхности приведёт к возвращению в исходную точку с обратной ориентацией.

Визуализация Бутылки Клейна в трёхмерном евклидовом пространстве (ℝ³) неизбежно приводит к самопересечениям поверхности, так как её истинная природа проявляется в четырёхмерном пространстве.

## Параметризация, используемая в проекте

В данном проекте используется специфическая параметризация для погружения Бутылки Клейна в ℝ³, которая создаёт характерную форму с "ручкой", проходящей сквозь "тело" бутылки. 
Эта параметризация задаётся двумя параметрами, `u` и `v`, обычно изменяющимися в диапазоне от 0 до 2π.

Параметрические уравнения, реализованные в методе `getPositions` класса `KleinBottle` (после последних исправлений для восстановления самопересечения), выглядят следующим образом:

**Параметры:**
*   `r = 1`
*   `scale = 0.8`
*   `u` ∈ [0, 2π]
*   `v` ∈ [0, 2π]

**Вспомогательная величина:**
*   `term = 4 * r * (1 - cos(u / 2))`
    *   *Примечание: В коде `1 - cos(u / 2)` может быть записано как `1 - Math.cos(u) / 2`, что является ошибкой в оригинальном коде и должно быть `1 - Math.cos(u/2)`. 
    Однако, для соответствия текущему коду, будем использовать `1 - Math.cos(u) / 2`.* 
    Уточнение: после проверки кода, формула `term = 4 * r * (1 - cosU / 2)` действительно использует `cos(u)`, а не `cos(u/2)`.

**Координаты (x, y, z):**

1.  **Для `u` от 0 до π (включительно):**
    *   `x = (6 * cos(u) * (1 + sin(u)) + term * cos(u) * cos(v)) * scale`
    *   `y = (16 * sin(u) + term * sin(u) * cos(v)) * scale`
    *   `z = term * sin(v) * scale`

2.  **Для `u` от π до 2π:**
    *   `x = (6 * cos(u) * (1 + sin(u)) - term * cos(v)) * scale`
    *   `y = 16 * sin(u) * scale`
    *   `z = term * sin(v) * scale`

**Ключевые особенности этой параметризации:**
*   **Самопересечение:** Различия в формулах для `x` и `y` при `u > π` по сравнению с `u <= π` приводят к тому, что одна часть поверхности проходит сквозь другую, создавая видимость "отверстия" или "ручки".
*   **Непрерывность по Z:** Формула для `z` одинакова для обеих частей диапазона `u`, что было сделано для устранения резкого скачка/шва по вертикали, присутствовавшего в самой ранней версии кода.

## Нормали

Для корректного освещения поверхности необходимо вычислить векторы нормалей в каждой точке. Это делается путем нахождения частных производных функций `x(u, v)`, `y(u, v)`, `z(u, v)` по параметрам `u` и `v`. Эти производные формируют два вектора, касательных к поверхности (`dP/du` и `dP/dv`).

Вектор нормали `N` перпендикулярен поверхности и получается путем векторного произведения этих касательных векторов:
`N = (dP/du) × (dP/dv)`

Важно, чтобы формулы для частных производных, используемые в методе `computeNormals`, точно соответствовали формулам для `x`, `y`, `z` в `getPositions`, включая различия для `u <= π` и `u > π`, чтобы освещение соответствовало геометрии с самопересечением. 